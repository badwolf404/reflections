What happens when you initialize a repository? Why do you need to do it? 
When you initialize a repository git install all the nessary meta data into a .git folder. The period before the name tells the OS to keep this file hidden. It needs to be done so git can set up all of the needed information into this special folder to keep track of all of the commits and data associated with that. 

How is the staging area different from the working directory and the repository? What value do you think it offers?
The staging area is a space that git uses to stage all of the needed files for the commit. It allows the user to be selective about what they commit. I think this is extremely valuable because you want the commits to be logical. They need to a defined change that is being commited. It saves the user from committing data that is not completed. 
How can you use the staging area to make sure you have one commit per logical change?
You can use the "git diff" command to check the difference between the staging and the working directories. It will show all of the changes between the two so you can make sure your commit contains one logical change. If you also use "git diff --staged" it will compare the staging area to the last commit so you can also review the changes you are about to commit to make sure if match the rule one logical change per commit. 
What are some situations when branches would be helpful in keeping your history organized? How would branches help?
If you were to create a different version of the game with an experimental feature or different language each one of those would consitute its own branch. It would allow you to have multiple version of your program in the same repo with out making changes to the master. It would also allow you to switch between all of these versions without any loss of data or risk to the master file. 
How do the diagrams help you visualize the branch structure?
Diagrams are extremely useful because they can help you keep track of what version you are on of your program. It also allows your to keep track of all of the branches you create and possible commits that may not be included and would be lost. 
What is the result of merging two branches together? Why do we represent it in the diagram the way we do?
The result of mergeing the two branches together is that both changes to the files from each branch are included now in the master branch. The parent commit for this merge commit is the head of both pervious branches. Represent this in the diagram so we get a linear view of the branches and commits made to this repo. 
What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?
The pros of Gits automatic merging is it will try and do it best to make the ideal choice to take the most current code and apply that to the master or branch. It also will save you sometime so you dont have to diff every single change. There may be a point where git cannot handle the logic and it will report a conflict that you need to resolve. This save the user time and only gets the user involved when it is needed. 